## Ответы на контрольные вопросы:
1.  В чем основная идея __полиморфизма__? Как он реализуется в Python.\
    Основная идея полиморфизма заключается в том,
что разные классы могут предоставлять свои реализации одних и тех же методов, и при этом их можно использовать единообразно.
Это позволяет объектами разных типов, не зная заранее их классы.\
\
В Python полиморфизм реализуется через механизмы наследования и перегрузки методов.\
\
Хочется привести неоригинальный, но базовый пример с голосами животных:
~~~
class Dog:
    def sound(self):
        return "Woof"

class Cat:
    def sound(self):
        return "Meow"

def make_sound(animal):
    print(animal.sound())

dog = Dog()
cat = Cat()
make_sound(dog) #--> Woof
make_sound(cat) #--> Meow
~~~


2.  Зачем переопределять метод `__radd__()` наравне с 
`__add__()`?\
Метод `__radd__()` нужен для симметричной поддержки сложения. Если в классе прописана функция сложения слева, то для сложения справа необходимо использовать `__radd__()`. В теории в `__radd__()` можно сослаться на `__add__()`, если операция сложения справа и слева эквивалентны. Однако в случае, если необходимо отразить разницу этих операций, нужно отдельно прописать новую функцию в `__radd__()`.\
\
Пример:
~~~
class MagicNumber:
    def __add__(self, other):
        return other + 1

    def __radd__(self, other):
        return other + 2

print(MagicNumber() + 3)  # 4 
print(3 + MagicNumber())  # 5 
~~~
3. Как можно описать взаимоотношения 
__родительского__ и __дочернего__ классов?\
Взаимоотношения родительского и дочернего классов можно описать как "наследование" (ваааау). Дочерний класс наследует все свойства и методы родительского класса. Это позволяет дочернему классу использовать все функции родителя, а также изменять или расширять их. Родительский класс является более общим, а дочерний класс — более специфическим (более узким). Пример с деревом и берёзой был прекрасен). Соответственно, дерево - родительский класс, берёза - дочерний.

4. Для чего используется ключевое 
слово `super()`?\
Когда нам нужно изменить (переопределить) какой-то метод в дочернем классе, но при этом этот метод уже был определён в родительском, используется ключевое слово `super()`.\
Ключевое слово `super()` используется для вызова методов или конструкторов родительского класса из дочернего класса.\
Пример:
~~~
class Parent:
    def greet(self):
        print("Hello from Parent")

class Child(Parent):
    def greet(self):
        super().greet()
        print("Hello from Child")

child = Child()
child.greet() #"Hello from Child"
~~~

5. Какую роль играет порядок классов __предков__
при __множественном наследовании__?\
При множественном наследовании порядок классов предков определяет очередность поиска методов и атрибутов. Python использует алгоритм разрешения порядка методов `MRO — Method Resolution Order`, чтобы определить, какой метод вызывать при наличии нескольких предков (по факту некоторая модификация dfs).

~~~
class A:
    def greet(self):
        print("Hello from A")

class B(A):
    def greet(self):
        print("Hello from B")

class C(A):
    def greet(self):
        print("Hello from C")

class D(B, C):
    pass

d = D()
d.greet() #Выведет "Hello from B"
~~~
Если очень хочется посмотреть, как `MRO` работает, то вот:
~~~
print(D.mro())
~~~
6. Зачем нужна __обработка исключений__? В каких 
случаях ее использование некорректно?\

Обработка исключений позволяет перехватывать ошибки, возникающие во время выполнения программы, и чтоб программа не вылетала (вместо этого будет выполнятся другая команда прописывается в except). Некорректное использование обработки исключений может происходить, например, когда исключения используются для управления потоком программы, а не для обработки ошибок. Или, возможно, если перехватываются все исключения, что может скрыть реальные ошибки.

7. Зачем в блоке `try` использовать раздел
`finally`?\

Блок `finally` выполняется всегда, независимо от того, было исключение в блоке `try` или нет. Он используется для освобождения ресурсов (например, закрытия файлов), когда нужно гарантировать выполнение определенного кода, даже если произошла ошибка.

Пример:
~~~
try:
    file = open('file.txt', 'r')
finally:
    file.close()  # Файл будет закрыт в любом случае
~~~
8. Что нужно сделать, чтобы реализовать 
свое собственное __исключение__?\
Чтобы реализовать собственное исключение, нужно создать новый класс, который наследуется от встроенного класса `Exception`. Это позволяет создавать свои специфичные ошибки и перехватывать их с помощью `except` в `try`.
9. Чем итератор отличается от генератора?\
Итератор — это объект, который реализует методы `__iter__()` и `__next__()`. Генератор — это особый вид итератора, который создается с помощью функции и ключевого слова `yield`. 
10. В чем минусы декорирования функций?\
Могут усложнить код для понимания, а так же привести к частичной потере данных декорируемой функцией (функция передаётся в декоратор, в отличие от её аргументов).
