## Ответы на контрольные вопросы:
1.  В чем основная идея __полиморфизма__? Как он реализуется в Python.\
    Основная идея полиморфизма заключается в том,
что разные классы могут предоставлять свои реализации одних и тех же методов, и при этом их можно использовать единообразно.
Это позволяет объектами разных типов, не зная заранее их классы.\
\
В Python полиморфизм реализуется через механизмы наследования и перегрузки методов.\
\
Хочется привести неоригинальный, но базовый пример с голосами животных:
~~~
class Dog:
    def sound(self):
        return "Woof"

class Cat:
    def sound(self):
        return "Meow"

def make_sound(animal):
    print(animal.sound())

dog = Dog()
cat = Cat()
make_sound(dog) #--> Woof
make_sound(cat) #--> Meow
~~~


2.  Зачем переопределять метод `__radd__()` наравне с 
`__add__()`?\
Метод `__radd__()` нужен для симметричной поддержки сложения. Если в классе прописана функция сложения слева, то для сложения справа необходимо использовать `__radd__()`. В теории в `__radd__()` можно сослаться на `__add__()`, если операция сложения справа и слева эквивалентны. Однако в случае, если необходимо отразить разницу этих операций, нужно отдельно прописать новую функцию в `__radd__()`.\
\
Пример:
~~~
class MagicNumber:
    def __add__(self, other):
        return other + 1

    def __radd__(self, other):
        return other + 2

print(MagicNumber() + 3)  # 4 
print(3 + MagicNumber())  # 5 
~~~
3. Как можно описать взаимоотношения 
__родительского__ и __дочернего__ классов?\
Взаимоотношения родительского и дочернего классов можно описать как "наследование" (ваааау). Дочерний класс наследует все свойства и методы родительского класса. Это позволяет дочернему классу использовать все функции родителя, а также изменять или расширять их. Родительский класс является более общим, а дочерний класс — более специфическим (более узким). Пример с деревом и берёзой был прекрасен). Соответственно, дерево - родительский класс, берёза - дочерний.

4. Для чего используется ключевое 
слово `super()`?\
Когда нам нужно изменить (переопределить) какой-то метод в дочернем классе, но при этом этот метод уже был определён в родительском, используется ключевое слово `super()`.\
Ключевое слово `super()` используется для вызова методов или конструкторов родительского класса из дочернего класса.\
Пример:
~~~
class Parent:
    def greet(self):
        print("Hello from Parent")

class Child(Parent):
    def greet(self):
        super().greet()
        print("Hello from Child")

child = Child()
child.greet() #"Hello from Child"
~~~

5. Какую роль играет порядок классов __предков__
при __множественном наследовании__?\
При множественном наследовании порядок классов предков определяет очередность поиска методов и атрибутов. Python использует алгоритм разрешения порядка методов `MRO — Method Resolution Order`, чтобы определить, какой метод вызывать при наличии нескольких предков (по факту некоторая модификация dfs).

~~~
class A:
    def greet(self):
        print("Hello from A")

class B(A):
    def greet(self):
        print("Hello from B")

class C(A):
    def greet(self):
        print("Hello from C")

class D(B, C):
    pass

d = D()
d.greet() #Выведет "Hello from B"
~~~
Если очень хочется посмотреть, как `MRO` работает, то вот:
~~~
print(D.mro())
~~~
7. Зачем нужна __обработка исключений__? В каких 
случаях ее использование некорректно?
8. Зачем в блоке `try` использовать раздел
`finally`?
9. Что нужно сделать, чтобы реализовать 
свое собственное __исключение__?
10. Чем итератор отличается от генератора?
11. В чем минусы декорирования функций?
