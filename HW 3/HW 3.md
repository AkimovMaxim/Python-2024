# Решение первого домашнего задания.

## Контрольные вопросы:
1. Как расшифровывается __СКВ (VCS)__ и зачем они нужны в больших проектах? **Система контроля версий**. Они нужны для управления изменениями в исходном коде и других файловых ресурсах. Как следует из названия **СКВ** контролируют версии программы, т.е. сохраняют историю изменения кода программы и обеспечивают совместную работу нескольких пользователей над одним проектом.
2. В чем отличия централизованных __СКВ__ от децентрализованных?  Централизованная СКВ - есть один сервер, от которого получают информацию все пользователи. Все изменения напрямую сохраняются на сервере. По запросу предоставляет актуальную версию проекта, но нельзя работать при потере связи с сервером.
   Децентрализованная СКВ - есть удалённый репозиторий, на котором хранится окончательная версия проекта. Пользователи могут редактировать локальный репозиторий даже без связи с удалённым. Но предоставляемая версия проекта не обязательно будет актуальной.
3. git - децентрализованная система контроля версий. GitHub - сервис, предоставляющий доступ к удалённым репозиториям.
4. Если разработчики пишут отдельные части проекта.
5. Git Merge - слияние принимает содержимое ветки источника и объединяет их с целевой веткой. Git Rebase - в отличие от слияния, перемещение перезаписывает историю, потому что она передает завершенную работу из одной ветки в другую. В процессе устраняется нежелательная история. Почему это плохо: для восстановления с удаленными ветками требуется принудительный пуш. Это приводит к обновлению всех веток, имеющих одно и то же имя, как локально, так и удаленно, и это ужасно.
6. Как расшифровывается __ООП__, в чем заключается идея __объекта__? Объектно-ориентированное программирование (_Примечания автора_: ну если бы я этого не знал, меня можно было бы сразу отчислять). __Идея объекта__: как пишет Википедия, объект - это сущность... Некоторое нечто, которое появляется, когда мы создаём экземпляр некоторого класса (при этом сам класс - это тоже объект). На объектах построено всё ООП, условно говоря, идея заключается в том, что мы задаём некоторый класс (кальку), а потом его экземпляры, которые являются объектами и обладают одинаковыми свойствами (полями и методами). Это говорит о том, что мы можем использовать эти объекты, которые имеют определённые атрибуты, для построения алгоритмов, программ, приложений, а не прописывать отдельные свойства каждому объекту каждый раз с нуля.
7. В чем опасность **переменных класса**? Если кратко, то опасность **переменных класса** заключается в том, что они могут обеспечивать неявную связь между экземплярами класса И экземпляром и самим классом. Как бы то ни было, класс в Python является объектом. Пусть наш класс обладает переменной *x*. Если мы зададим какое-то количество экземпляров класса И у данных экземпляров не будет полей, соответствующих переменной *x*, то при её вызове экземпляры подтянут значение переменной из класса. Если же изменять эту переменную внутри класса, то она соответствующим образом изменится у всех экземпляров при отсутствии у них полей для этой переменной (*Прим: если у экземпляра есть поле со значением *x*, то при вызове переменной экземпляр не будет подтягивать значение, указанное в классе, а будет выводить то, что у него записано в поле*).
**Интересный момент** (для меня) с семинара: при использовании некоторых встроенных функций к полю (с изменяемым типом данных) какого-то конкретного экземпляра класса (например, **append** для списка), то значение переменной изменится у всех экземпляров класса и у самого класса. Если же вместо этого для экземпляра использовать *присваивание*, то изменится только поле соотвествующего экземпляра.\
Пример кода с семинара --> находится в папке семинара и мне лень его вставлять:)
8. Какую роль играет ключевое слово `self`? Ключевое слово в Python `self` используется для представления экземпляра (объекта) класса, с которым вы работаете. Он позволяет получить доступ к атрибутам и методам класса в Python. (`self` должен быть первым параметром любого метода в классе, в том числе и метода, который является конструктором `__init__`). По-простому, `self` - ссылка на самого себя. Это приводит к тому, что следующие записи эквивалентны:
~~~
 class Student:
     def __init__(self, x):
         self.x = x

     def increase_x(self, value):
         self.x += value


 A = Student(7)
 A.increase_x(2)
 Student.increase_x(A, 2)
~~~
9. Как переменная `__dict__` связана с 
остальными __переменными класса__? Что это говорит нам о природе объектов в __Python__? `__dict__` - это словарь, в котором хранятся все атрибуты класса и его экземпляра, где ключи - имена полей или переменных, а значения... их значения) Метод `__dict__` буквально утверждает, что любой объект и класс - это словарь. Всего навсего. И не просто словарь, который мы можем вызвать и получить инфу обо всех атрибутах, а словарь, наполнение которого мы можем менять сами, меняя объект. Таким образом, любой объект реализован через словарь (а словари через класс, но об этом тссс).
10. В чем заключается основная идея __инкапсуляции__?
    > Идея инкапсуляции очень простая и она заключается в том, что люди зачастую не хотят разбираться с тем, как какие-то вещи внутри работают, - Горшков Т.В.
    > 
Если по умному, то инкапсуляция - это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании. (Но Python инкапсуляция, по факту, работает на уровне договорённости, так как и к приватным, и к защищённым данным любой пользователь может получить доступ, используя либо встроенные методы по типу `__dict__` или вызывая защищённые данные `._name`)
**Пример**:
~~~
 class Teacher:
     def __init__(self):
         self.__value = 0

     def increment(self, x):
         self.__value += x


 A = Teacher()
 print(A.__value) #--> Error
~~~
