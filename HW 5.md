## Ответы на контрольные вопросы:
1.  В чем основная идея __полиморфизма__? Как он реализуется в Python.\
    Основная идея полиморфизма заключается в том,
что разные классы могут предоставлять свои реализации одних и тех же методов, и при этом их можно использовать единообразно.
Это позволяет объектами разных типов, не зная заранее их классы.\
\
В Python полиморфизм реализуется через механизмы наследования и перегрузки методов.\
\
Хочется привести неоригинальный, но базовый пример с голосами животных:
~~~
class Dog:
    def sound(self):
        return "Woof"

class Cat:
    def sound(self):
        return "Meow"

def make_sound(animal):
    print(animal.sound())

dog = Dog()
cat = Cat()
make_sound(dog) #--> Woof
make_sound(cat) #--> Meow
~~~


2.  Зачем переопределять метод `__radd__()` наравне с 
`__add__()`?\
Метод `__radd__()` нужен для симметричной поддержки сложения. Если в классе прописана функция сложения слева, то для сложения справа необходимо использовать `__radd__()`. В теории в `__radd__()` можно сослаться на `__add__()`, если операция сложения справа и слева эквивалентны. Однако в случае, если необходимо отразить разницу этих операций, нужно отдельно прописать новую функцию в `__radd__()`.\
\
Пример:
~~~
class MagicNumber:
    def __add__(self, other):
        return other + 1

    def __radd__(self, other):
        return other + 2

print(MagicNumber() + 3)  # 4 
print(3 + MagicNumber())  # 5 
~~~
- Как можно описать взаимоотношения 
__родительского__ и __дочернего__ классов?
- Для чего используется ключевое 
слово `super()`?
- Какую роль играет порядок классов __предков__
при __множественном наследовании__?
- Зачем нужна __обработка исключений__? В каких 
случаях ее использование некорректно?
- Зачем в блоке `try` использовать раздел
`finally`?
- Что нужно сделать, чтобы реализовать 
свое собственное __исключение__?
- Чем итератор отличается от генератора?
- В чем минусы декорирования функций?
